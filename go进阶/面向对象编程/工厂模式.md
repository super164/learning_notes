## 针对于工厂模式的理解

1. 解决了go语言中没有构造函数的问题

   如果想要创建一个对外不开放包中的对象，不能够直接创建，可以通过所谓的“工厂模式”通过函数来实现构造的过程

   ```go
   //该代码所属model包中
   // 定义一个结构体（假设首字母小写，包内私有）
   type person struct {
       name string
       age  int
   }
   
   // 工厂函数（首字母大写，对外暴露）
   func NewPerson(name string, age int) *person {
       return &person{name: name, age: age}
   }
   ```

   对于上述代码中的NewPerson就是工厂函数，这样在另一个包中就可以通过该函数实现创建

   ```go
   //main包中创建
   var per = model.NewPerson("小明",18)
   fmt.Println(*per)
   ```

2. 支持多态和接口抽象
   Go 中多态通过 “接口” 实现，工厂模式可以根据不同参数返回不同的接口实现，而外部无需关心具体类型。

   例如，定义一个 Shape 接口，工厂函数根据类型返回 Circle 或 Rectangle：

   ```go
   // 接口
   type Shape interface {
       Area() float64
   }
   // 具体实现（私有）
   type circle struct {
       radius float64
   }
   type rectangle struct {
       width, height float64
   }
   // 工厂函数：根据类型创建不同实例
   func NewShape(shapeType string, params ...float64) (Shape, error) {
       switch shapeType {
       case "circle":
           return &circle{radius: params[0]}, nil
       case "rectangle":
           return &rectangle{width: params[0], height: params[1]}, nil
       default:
           return nil, errors.New("未知形状类型")
       }
   }
   ```

   外部调用时只需使用 `Shape` 接口，无需知道具体是 `circle` 还是 `rectangle`，实现了解耦。

3.  便于扩展和维护:

   新增类型时：只需修改工厂函数，无需改动外部调用代码（符合 “开闭原则”）。
   统一管理初始化逻辑：如果后续需要给所有对象添加初始化步骤（如日志、监控），只需在工厂函数中修改，无需逐个修改创建处。

4. 总之，Go 语言的工厂模式本质上是对 “结构体初始化” 的一种封装和抽象，弥补了没有构造函数的特性限制，在实际开发中，工厂模式能有效提升代码的可维护性、扩展性和安全性，是 Go 面向对象编程中不可或缺的模式。