# 协程并行(并发问题)

![image-20250801175536325](协程并行(并发)资源竞争问题.assets/image-20250801175536325.png)

```go
package main
import (
	"fmt"
	"time"
)
//需求：现在要计算 1-200 的各个数的阶乘，
//并且把各个数的阶乘放入到 map 中。最后显示出来。要求使用goroutine完成

// 1.编写一个函数，来计算各个数的阶乘，并放入到map中
// 2.我们启动协程多个，统计的将结果放入到map
// 3. map应该做出全局的
var (
	myMap = make(map[int]int, 10)
)
func test(n int) {
	res := 1
	for i := 1; i <= n; i++ {
		res *= i
	}
	myMap[n] = res
}
func main() {
	for i := 1; i <= 200; i++ {
		go test(i)
	}
	//程序休眠一下

	time.Sleep(time.Second * 10)
	for i, v := range myMap {
		fmt.Printf("map[%d]=%d\n", i, v)
	}
}

```

![image-20250801205756680](协程并行(并发)资源竞争问题.assets/image-20250801205756680.png)

多个协程同时向map中写东西，造成报错

# 解决方案

## 全局变量加锁同步改进程序

因为没有对全局变量 m 加锁，因此会出现资源争夺问题，代码会出现错误，提示concurrent map writes
解决方案：加入互斥锁
我们的数的阶乘很大，结果会越界，可以将求阶乘改成 sum += uint64 (i)

![image-20250801211314086](协程并行(并发)资源竞争问题.assets/image-20250801211314086.png)

```go
var (
	myMap = make(map[int]int, 10)
	//声明一个全局的互斥锁
	lock sync.Mutex //互斥锁
)

func test(n int) {
	res := 1
	for i := 1; i <= n; i++ {
		res *= i
	}
	//执行之前加锁
	lock.Lock()
	myMap[n] = res
	lock.Unlock()
}
func main() {
	for i := 1; i <= 20; i++ {
		go test(i)
	}
	//程序休眠一下

	time.Sleep(time.Second)
	//lock.Lock()
	for i, v := range myMap {
		fmt.Printf("map[%d]=%d\n", i, v)
	}
	//lock.Unlock()
}
```