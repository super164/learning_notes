1. #### 切片定义后不可以直接使用，需要让其引用到一个数组，或者make一个空间供切片来使用 
>func main() {  
	var slice []int  
	fmt.Println(slice)  
}  
这样定义之后得到的slice为空
2. #### 切片使用不能越界。 
3. #### 简写方式： 
    1. var slice = arr[O:end]----》 var slice = arr[:end] 
    2. var slice = arr[start:len(arr)] ----》 var slice = arr[start:] 
    3. var slice = arr[O:len(arr)]----》 var slice = arr[:] 
4. #### 切片可以继续切片
```go
func main() {
	var intarr [6]int = [6]int{1, 2, 3, 4, 5, 6}
	var slice []int = intarr[1:4]
	fmt.Println(slice[0])
	fmt.Println(slice[1])
	fmt.Println(slice[2])
	//fmt.Println(slice[3])
	fmt.Println("---------------------------------------")
	//继续切片
	slice1 := slice[1:2]
	fmt.Println(slice1[0])
	//更改切片的值，其对应数组中的值也会发生改变
	slice1[0] = 97
	fmt.Println(slice)
	fmt.Println(intarr)
}
```

5. #### 切片可以动态增长
>底层逻辑：
>1. 底层追加元素的时候对数组进行扩容，老数组扩容为新数组
>2. 创建一个新数组，将老数组中的数复制到新数组中，在新数组中加上新数
>3. 如果想要得到追加后的slice，可以直接将结果赋值给原来的切片
```go
func main() {
	var intarr [6]int = [6]int{1, 2, 3, 4, 5, 6}
	//定义切片
	var slice []int = intarr[1:4]
	fmt.Println(slice)
	//增长
	slice1 := append(slice, 34, 23)
	fmt.Println(slice1)

	slice = append(slice, 34, 23)
	fmt.Println(slice)
}
```
>通过append函数进行追加，也可以将切片追加给切片  
slice3 := []int{99,11}  
slice = append(slice,slice3...)//其中的`...`是必写的  

6. #### 切片的拷贝
```go
func main() {
	//定义一个切片
	a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	//再定义一个切片
	b := make([]int, 10)
	//将a中的数值赋值给b
	copy(b, a)
	fmt.Println(b)
}
```